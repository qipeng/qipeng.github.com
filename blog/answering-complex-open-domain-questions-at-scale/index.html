<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Answering Complex Open-domain Questions at Scale | Peng Qi </title> <meta name="author" content="Peng Qi"> <meta name="description" content="The NLP community has made great progress on open-domain QA, but our systems still struggle to answer complex open-domain questions in an large collection of text. We present an efficient and explainable method for enabling multi-step reasoning in these systems. "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <script id="Cookiebot" src="https://consent.cookiebot.com/uc.js" data-cbid="50a71157-b394-48ad-8f66-2917ea22afc0" type="text/javascript" async></script> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons|Ma+Shan+Zheng&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon.ico?dc1f91af22f2410197efd400b56886d2"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://qipeng.me//blog/answering-complex-open-domain-questions-at-scale/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Peng</span> Qi </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Answering Complex Open-domain Questions at Scale</h1> <p class="post-meta"> Created in October 16, 2019 • 23 min read </p> <p class="post-tags"> <a href="/blog/2019"> <i class="fa-solid fa-calendar fa-sm"></i> 2019 </a>   ·   <a href="/blog/tag/questionanswering"> <i class="fa-solid fa-hashtag fa-sm"></i> QuestionAnswering</a>   <a href="/blog/tag/research"> <i class="fa-solid fa-hashtag fa-sm"></i> Research</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <blockquote> <p><strong>TL;DR:</strong> The NLP community has made great progress on open-domain question answering, but our systems still struggle to answer complex questions over a large collection of text. We present an efficient and explainable method for enabling multi-step reasoning in these systems.</p> </blockquote> <p>From search engines to automatic question answering systems, natural language processing (NLP) systems have drastically improved our ability to access knowledge stored in text, saving us countless hours spent memorizing facts and looking things up.</p> <figure> <a data-flickr-embed="true" href="https://www.flickr.com/photos/reedinglessons/2239767394/" title="Card Catalog" rel="external nofollow noopener" target="_blank"><img src="https://live.staticflickr.com/2129/2239767394_bbd6cab970_z.jpg" width="640" height="425" alt="Card Catalog"></a><script async="" src="//embedr.flickr.com/assets/client-code.js" charset="utf-8"></script> <figcaption> Who's old enough to remember these indexes and not just the search engine ones? </figcaption> </figure> <p>Today, whenever we have a question in mind, the answer is usually one Google/Bing search away. For instance, <em>“Which U.S. state is the largest by area?”</em></p> <figure> <img src="/blog/answering-complex-open-domain-questions-at-scale/google-alaska.png" width="90%"> <figcaption> Alaska! But also, great job, Google! </figcaption> </figure> <p>Other questions, however, are less straightforward. For example, <em>“Who was the first to demonstrate that GPS could be used to detect seismic waves?”</em> Google isn’t of much help if we were to directly type this question as a search query. On the other hand, the Internet’s encyclopedia, Wikipedia, does have an answer for us:</p> <figure> <img src="/blog/answering-complex-open-domain-questions-at-scale/dr-larson.png" width="90%"> <figcaption> Thank you, Dr. Larson! </figcaption> </figure> <p>Wouldn’t it be nice if an NLP system could answer this question for us, without us having to find the article ourselves? This problem, called <em>open-domain question answering (open-domain QA)</em>, is an active area of NLP research.</p> <h3 id="background-open-domain-qa">Background: Open-domain QA</h3> <p>Before diving into our new method for open-domain QA, let us first take a moment to understand the problem setup, challenges, and why existing solutions are not quite enough to answer complex questions.</p> <h4 id="open-domain-vs-closed-domain--restricted-context">Open-domain vs Closed-domain / Restricted-context</h4> <p>The first question answering systems built by NLP researchers, such as <a href="https://web.stanford.edu/class/linguist289/p219-green.pdf" rel="external nofollow noopener" target="_blank">BASEBALL</a> and <a href="https://www.semanticscholar.org/paper/Lunar-rocks-in-natural-english%3A-explorations-in-Woods/6390e2772c3359e4f3b5430423ac996473449ebb" rel="external nofollow noopener" target="_blank">LUNAR</a>, were highly domain-specific. They were adept at answering questions about US baseball players over the period of one specific year and about lunar rocks brought back to Earth, but not terribly helpful beyond the domains they were built for. In other words, they are <em>closed-domain</em>.</p> <p>Since then, researchers have moved towards tackling open-domain QA. In open-domain QA, the questions are not limited to predefined domains and domain knowledge; ideally, the system should be able to sift through a very large amount of text documents to find the answer for us.</p> <p>Single-document open-domain QA (also known as <em>reading comprehension</em>) is one of the research areas seeing recent breakthroughs in natural language processing, where an NLP system is given a single document (or just a paragraph) that might contain the answer to a question, and is asked to answer the question based on this context. Take our Dr. Larson question for an example (<em>“Who was the first to demonstrate that GPS could be used to detect seismic waves?”</em>). A single-document QA system might be trained to answer this question given only the Wikipedia page <em>“Kristine M. Larson”</em>. This is the format of many popular question answering datasets used in the NLP community today, e.g., <a href="https://rajpurkar.github.io/SQuAD-explorer/" rel="external nofollow noopener" target="_blank">SQuAD</a>.</p> <p>Question answering systems trained on SQuAD are able to generalize to answering questions about personal biographies.</p> <figure> <img src="/blog/answering-complex-open-domain-questions-at-scale/bio-peng.png" width="90%"> <figcaption> Recent reading comprehension systems can answer our question, given appropriate context. Demo credit: <a href="https://demo.allennlp.org/reading-comprehension/OTk1OTky" rel="external nofollow noopener" target="_blank">AllenNLP</a>. </figcaption> </figure> <p>However, such systems cannot help us answer our question about Dr. Larson if we didn’t already know to look at her biography, which is quite limiting.</p> <p>To solve this, researchers are developing question answering systems over large text collections. Instead of provided with the exact context necessary to answer the question, the system is required to sift through a collection of documents to arrive at the answer, much like how we search for answers on the web. This setting, called <em>open-context open-domain QA</em>, is much more challenging than reading comprehension. But, it is also a lot more useful when we have a question in mind but don’t really have a good idea where the answer might be from. The main challenge, besides those of restricted-context QA, is to narrow down the large collection of texts to a manageable amount with scalable approaches, such that we can run reading comprehension models to arrive at the answer.</p> <h4 id="open-domain-qa-systems">Open-domain QA Systems</h4> <p>Inspired by the <a href="https://trec.nist.gov/data/qamain.html" rel="external nofollow noopener" target="_blank">series of question answering competitions at the Text REtrieval Conference</a> (TREC), researchers in recent years have started to look into adapting powerful neural-network-based QA models to the open-domain task.</p> <p><a href="https://www.cs.princeton.edu/~danqic/" rel="external nofollow noopener" target="_blank">Danqi Chen</a> and collaborators first combined traditional search engines with modern, neural question answering systems to attack this problem. Their approach to open-domain QA, named <a href="https://arxiv.org/pdf/1704.00051.pdf" rel="external nofollow noopener" target="_blank">DrQA</a>, is simple and powerful: given a question, the system uses it to search a collection of documents for context documents that may contain the answer. Then, this reduced context is the input to a reading comprehension system, which predicts the final answer.</p> <figure> <img src="/blog/answering-complex-open-domain-questions-at-scale/drqa.png" width="90%"> <figcaption> Illustration of Chen et al.'s "DrQA" model, which was presented at ACL 2017. Figure from the official <a href="https://github.com/facebookresearch/DrQA" rel="external nofollow noopener" target="_blank">Github repo</a>. </figcaption> </figure> <p>Most of the recent research in open-domain QA has largely followed this two-stage approach of retrieving and reading, with added features such as reranking (see, for example, <a href="https://arxiv.org/abs/1709.00023" rel="external nofollow noopener" target="_blank">(Wang et al., 2018)</a>) and neural retrieval systems and better joint training (see, for example, <a href="https://openreview.net/pdf?id=HkfPSh05K7" rel="external nofollow noopener" target="_blank">(Das et al., 2019)</a> and <a href="https://arxiv.org/pdf/1906.00300.pdf" rel="external nofollow noopener" target="_blank">(Lee et al., 2019)</a>).</p> <h4 id="the-challenge-of-complex-open-domain-questions">The Challenge of Complex Open-domain Questions</h4> <p>All systems that follow this retrieve-and-read paradigm are ill-equipped to handle complex questions. Let’s walk through an illustrative example of why that is together.</p> <p>We all forget the names of celebrities from time to time. Suppose, one day, you are curious: <em>“What is the Aquaman actor’s next movie?”</em> To answer this question, you would probably first search for <em>“Aquaman”</em> or <em>“the Aquaman actor”</em> to find out who he/she is. Hopefully after scrolling through a few top search results, you will realize the answer is <em>“Jason Momoa”</em>, and then move on to finding out what his next movie is.</p> <p>In this simple example, not all of the supporting evidence needed to answer the question can be readily retrieved from the question alone, i.e., there’s a knowledge discovery problem to solve.<sup id="fnref:2"><a href="#fn:2" class="footnote" rel="footnote" role="doc-noteref">1</a></sup> This makes these questions difficult for retrieve-and-read open-domain QA systems, because there is usually some evidence that lack a strong semantic overlap with the question itself. Below is a sketch of the relations between the real-world entities that illustrate the multiple steps of reasoning required to answer this question.</p> <figure> <img src="/blog/answering-complex-open-domain-questions-at-scale/jason-momoa.png" width="90%"> <figcaption> Reasoning required to answer the question "What is the Aquaman actor's next movie?". In this case, "Jason Momoa" is the missing link that connects the question to its answer, but cannot be easily retrieved based on the question. </figcaption> </figure> <p>One solution to this problem might be to train neural retrieval and reading comprehension models jointly to update queries to find more evidence (Das et al. (2019) set out to do just that). While this might also work in our setting, pretraining the neural retriever with distant supervision to promote documents that contain the answer string will likely fail because of the missing semantic overlap between the question and all necessary documents. End-to-end training will also be prohibitively expensive, because the search space for queries beyond the first step of reasoning is enormous. Even if one manages to train a neural system to accomplish this task, the resulting system is probably very computationally inefficient and not very explainable.</p> <p>So, can we build an open-domain QA system that is capable of handling complex, multi-step reasoning questions, and doing so in an efficient and explainable manner? We present such a system in our new EMNLP-IJCNLP paper – <a href="https://nlp.stanford.edu/pubs/qi2019answering.pdf" rel="external nofollow noopener" target="_blank">Answering Complex Open-domain Questions Through Iterative Query Generation</a>.</p> <h3 id="answering-complex-open-domain-questions">Answering Complex Open-domain Questions</h3> <p>To introduce our system, we start with the overall strategy we use to address the problem of mutli-step reasoning in open-domain QA, before moving on to the dataset we evaluate our system on and experimental results.</p> <h4 id="overall-strategy">Overall Strategy</h4> <p>As we have seen, retrieve-and-read systems can’t efficiently handle complex open-domain questions that require multiple steps of reasoning, because (a) these questions require multiple supporting facts to answer, and (b) it is usually difficult to find all supporting facts necessary with only the question. Ideally, we want a system to be able to iterate between “reading” the information retrieved and finding further supporting evidence if necessary, just like a human.</p> <p>That is exactly where the “iterative query generation” part of the paper title comes into play. We propose an open-domain QA system that iteratively generates natural language queries based on the currently retrieved context and retrieves more information if needed before finally answering the question. This allows us to (a) retrieve multiple supporting facts with different queries, and (b) make use of documents retrieved in previous iterations to generate queries that wouldn’t have been possible from the question alone. Moreover, because our system generates natural language queries, we can still leverage off-the-shelf information retrieval systems for efficient retrieval. Furthermore, the steps our model follows are more explainable to a human, and allow for human intervention at any time to correct its course.</p> <p>Given the English Wikipedia as our source of textual knowledge, the full system operates as follows to answer the question <em>“Which novel by the author of ‘Armada’ will be adapted as a feature film by Steven Spielberg?”</em>:</p> <figure> <img src="/blog/answering-complex-open-domain-questions-at-scale/golden-retriever.png" width="90%"> <figcaption> The proposed model answers the question "Which novel by the author of 'Armada' will be adapted as a feature film by Steven Spielberg?". The system first iterates between reading and retrieving to gather supporting facts, then concatenates all the top retrieval results and feeds them into a restricted-context QA model with the question to generate the final answer. </figcaption> </figure> <p>To answer this question, the model starts by generating a query to search Wikipedia to find information about the novel <em>Armada</em>. After “reading” the retrieved articles, it then attempts to search for <em>Ernest Cline</em> (the name of the author) for more information. Finally, when we have retrieved all the context necessary to answer the question, we concatenate the top retrieved articles from these retrieval steps, and feed them into a restricted-context QA system to predict the final answer.</p> <p>The main challenge in building this model lies in training the query generators collaboratively to generate useful queries for retrieving all the necessary information. Our main contribution is an efficient method for training these query generators with very limited supervision about which documents to retrieve, yielding a competitive system for answering complex and open-domain questions. Our method is based on the crucial observation that, if the question can be answered with knowledge from the corpus, then there exists a progressive chain (or graph) of reasoning we can follow. In other words, we note that at any given time in the process of finding all supporting facts, there is some strong semantic overlap between <em>what we already know</em> (the question text, plus what we have found so far), and <em>what we are trying to find</em> (the remaining supporting facts).</p> <figure> <img src="/blog/answering-complex-open-domain-questions-at-scale/needle-haystack.png" width="90%"> <figcaption> Finding the multiple supporting facts necessary to answer complex questions is much like finding multiple needles in a haystack. Instead of looking for them independently, we make use of the thread connecting these needles, which is the strong semantic overlap between what we know and what we are trying to find. </figcaption> </figure> <p>In the beginning, the question the system is asked is all the information <em>we already know</em>. We are <em>trying to find</em> any document part of reasoning chain needed to answer this question. Based on our observation, at least one of the gold documents<sup id="fnref:4"><a href="#fn:4" class="footnote" rel="footnote" role="doc-noteref">2</a></sup> would have strong semantic overlap with the question, and our goal is to find one such document to bootstrap our chain of reasoning. In our Armada example, this document would be the Wikipedia page of Armada the novel, where the overlap is the name <em>“Armada”</em>, and the fact that it’s a novel. To find this document with the help of a text-based information retrieval (IR) system, we just need to identify this overlap and use it as the search query.</p> <p>After one step of retrieval, we have hopefully retrieved the <em>“Armada (novel)”</em> page from Wikipedia, among others. If, at training time, we also know that the <em>“Ernest Cline”</em> page is the next missing link in our chain of reasoning, we can apply the same technique. Now, the semantic overlap between <em>what we know</em> (the question, the <em>“Armada (novel)”</em> page, plus some other Wikipedia pages), and <em>what we are trying to find</em> (<em>“Ernest Cline”</em>) to generate the desired query, <em>“Ernest Cline”</em>. To find this semantic overlap, we simply employ longest common substring or longest common subsequence algorithms between <em>the knowns</em> and <em>the wanted</em>.</p> <p>With the desired queries at each step of reasoning, we can then train a model to predict them from the retrieval context (question + already retrieved documents) at each step. We then use these query generators to complete the task of open-domain multi-step reasoning. We cast the query generation problem as one of restricted-context QA, since the goal is to map the given question and (retrieved) context to some target derived from the context.</p> <p>We name the full system GoldEn (Gold Entity) Retriever, because the model-retrieved Wikipedia pages are mostly entities, and it’s a fun name for a retrieval-oriented model! Below are some example questions and the desired queries we train the query generators with:</p> <figure> <table> <tr> <th>Question</th> <th>Step 1 Query</th> <th>Step 2 Query</th> </tr> <tr> <td>What government position was held by the woman who portrayed Corliss Archer in the film Kiss and Tell?</td> <td>Corliss Archer in the film Kiss and Tell</td> <td>Shirley Temple</td> </tr> <tr> <td>Are Giuseppe Verdi and Ambroise Thomas both Opera composers?</td> <td>Giuseppe Verdi</td> <td>Ambroise Thomas</td> </tr> </table> <figcaption> Example queries generated from our overlap-finding process to train the query generators in GoldEn Retriever. As you can see in the first example, the query at Step 2 reveals information we can only find through iterative retrieval, and is not contained in the original question. </figcaption> </figure> <p>Two practical notes should be mentioned here. First, it is not difficult to see that our observation that supervision signal for query generation can be derived from this semantic overlap generalizes to any number of supporting documents. It also requires no additional knowledge about how the question can or should be decomposed into sub-questions to answer (which previous work has studied, e.g., <a href="https://www.aclweb.org/anthology/N18-1059" rel="external nofollow noopener" target="_blank">(Talmor and Berant, 2018)</a> and <a href="https://www.aclweb.org/anthology/P19-1613" rel="external nofollow noopener" target="_blank">(Min et al., 2019)</a>). As long as the gold supporting documents are known at training time, we can use this technique to construct the chain of reasoning in an open-domain setting very efficiently at scale. Second, we further make no assumption about knowledge of the order in which documents should be retrieved. At any given step of open-domain reasoning, one can enumerate all of the documents that have yet to be retrieved, find its semantic overlap with the retrieval context, and launch searches with these generated queries. Documents that are in the immediate next step of reasoning will naturally be more discoverable, and we can choose the desired queries accordingly. In our Armada example, for instance, the overlap between the question and the Ernest Cline article is <em>“Steven Spielberg”</em>, <em>“film”</em>, etc, which lead us nowhere close to the <em>“Ernest Cline”</em> page, thus these are not chosen as the first-step query at training time.</p> <h4 id="dataset-hotpotqa">Dataset: HotpotQA</h4> <p>To test the performance of GoldEn Retriever, we evaluate it on <a href="https://hotpotqa.github.io/" rel="external nofollow noopener" target="_blank">HotpotQA</a>, a recent multi-hop question answering dataset presented at EMNLP 2018 (by me &amp; collaborators). HotpotQA is a crowd-sourced QA dataset on English Wikipedia articles, in which crowd-workers are presented the introductory paragraphs from two related Wikipedia articles and asked to generate questions that require reasoning with both paragraphs to answer. Our example question about the Armada novel is one such question from this dataset. To encourage the development of explainable QA systems, we also asked crowd workers to highlight the sentences from these paragraphs that support their answer (we call these “supporting facts”), and ask QA systems to predict them at test time.</p> <p>HotpotQA features two evaluation settings: a few-document distractor setting, and an open-domain fullwiki setting, which we focus on, where the system is only given the question and the entire Wikipedia to predict the answer from. HotpotQA also features a diverse range of reasoning strategies, including questions involving missing entities (our Armada example, where Ernest Cline is not in the question), intersection questions (<em>What satisfies property A and property B?</em>), and comparison questions, where two entities are compared by a common attribute, among others.<sup id="fnref:3"><a href="#fn:3" class="footnote" rel="footnote" role="doc-noteref">3</a></sup></p> <p>QA systems on this dataset are evaluated on two aspects, answer accuracy and explainability. Answer accuracy is evaluated with answer exact matches (EM) and unigram F1, and explainability is similarly evaluated with EM and F1 by calculating the supporting fact overlap between predictions and annotations. These two aspects are unified by joint EM and F1 metrics, which encourage QA systems to work well on both.</p> <p>We make two simplifications to the GoldEn Retriever system on this dataset. First, we limit the number of retrieval steps to two to match the number of gold supporting documents for all questions in HotpotQA, and avoid having to learn an extra stopping criterion. Second, we assume that all queries are contiguous spans of text in the retrieval context, and use the document reader in DrQA, an extractive question answering system, to predict them during test time. To derive the desired search queries, we employ longest common substring and longest common subsequence algorithms to find the semantic overlap between the retrieval context and the desired documents, and choose the one that results in the IR performance. For the IR engine, we use <a href="https://elastic.co/" rel="external nofollow noopener" target="_blank">Elasticsearch</a> with a unigram-bigram index over the same Wikipedia dump HotpotQA was constructed on.</p> <p>For the final restricted-context QA component, we use a modified BiDAF++ model in this work. For more technical details, please refer to <a href="https://nlp.stanford.edu/pubs/qi2019answering.pdf" rel="external nofollow noopener" target="_blank">our paper</a>.</p> <h4 id="results">Results</h4> <p>We evaluate the effectiveness of our GoldEn Retriever model on two aspects: its performance on retrieving the gold supporting documents, and it’s end-to-end performance in question answering.</p> <p>For retrieval performance, we compare GoldEn Retriever to a retrieve-and-read QA system that just retrieves once with the question. We evaluate these approaches on the recall of the two gold paragraphs when a total of 10 paragraphs are retrieved by each system, because this metric reflects the ceiling performance of the entire QA system if the restricted-context QA component were perfect.</p> <figure> <img src="/blog/answering-complex-open-domain-questions-at-scale/ir-recall.png" width="90%"> <figcaption> Retrieval performance of a retrieve-and-read system vs GoldEn Retriever on the gold paragraphs. </figcaption> </figure> <p>As can be seen from the figure, while both systems achieve decent recall on the paragraph that is usually more connected to the question (“Paragraph 1” in the figure), GoldEn Retriever obtains significant improvement through iterative retrieval with query generation on the other paragraph (~24% improvement). This means for about 24% of the questions, GoldEn Retriever is able to find both gold supporting documents while the retrieve-and-read system can’t. Further analysis shows that this is mainly from the improved recall for non-comparison questions (for which recall improved by about 25%), where the retrieval problem is less trivial.</p> <p>For end-to-end QA performance, we compare GoldEn Retriever against various retrieve-and-read baselines on the development set, as well as systems submitted to the public leaderboard on the hidden test set.</p> <figure> <img src="/blog/answering-complex-open-domain-questions-at-scale/fullwiki-joint-f1.png" width="90%"> <figcaption> Comparing GoldEn Retriever against various other systems on HotpotQA's fullwiki setting. </figcaption> </figure> <p>We first contrast the performance of the QA component when using the IR system originally used in HotpotQA (as reflected by the released fullwiki dev set) and Elasticsearch in an retrieve-and-read setting. As can be seen by the leftmost two bars in the figure, a better search engine does improve end-to-end performance (from 22.75% F1 to 27.11%). However, this is still far from the best previously published system (34.92% F1 on the test set, which is empirically ±2% from the model’s dev set performance). With GoldEn Retriever, we improve this state of the art to 39.13% F1, which is significant especially if one considers that the previous state-of-the-art model uses BERT and we don’t. Although this doesn’t match the contemporaneous work which achieves 47.6% F1 with another BERT-based model, we see that if our query generators were able to faithfully reproduce the desired queries on the dev set, the performance of our system wouldn’t have been far off (“Oracle IR”).</p> <p>For explainability, aside from reporting supporting fact metrics that are part of HotpotQA’s evaluation, we can also look at the search queries GoldEn Retriever generates on the dev set. As can be seen in the example below, the natural language queries generated by the model are very understandable. Furthermore, one can see where the model is making mistakes and correct it in the system if needed.</p> <figure> <table> <tr> <th>Question</th> <th>Step 1 Predicted</th> <th>Step 2 Predicted</th> </tr> <tr> <td>What video game character did the voice actress in the animated film Alpha and Omega voice?</td> <td>voice actress in the animated film Alpha and Omega <span class="green-italic">(animated film Alpha and Omega voice)</span> </td> <td>Hayden Panettiere</td> </tr> <tr> <td>Yau Ma Tei North is a district of a city with how many citizens?</td> <td>Yau Ma Tei North</td> <td>Yau Tsim Mong District of Hong Kong <span class="green-italic">(Hong Kong)</span> </td> </tr> </table> <figcaption> Examples of queries generated by GoldEn Retriever on dev set examples. The model-generated queries are shown in black, and the heuristic-generated "desired queries" are shown in parenthesis in <span class="green-italic">green italic font</span> when they differ from the model-generated ones. In the first example, we see that the model actually generates a constituent whereas the heuristics largely ignores constituency structure; in the second example, however, the model generated a Step 2 query that is overly specific. </figcaption> </figure> <h3 id="resources">Resources</h3> <p>To help facilitate future research in open-domain multi-step reasoning, we make the following resources publicly available:</p> <ul> <li>The code to reproduce our results and our pretrained models</li> <li>Generated “desired” query files and modified HotpotQA training and development files generated from the heuristics to train GoldEn Retriever models</li> <li>Predicted search queries and dev/test set input for our restricted-context QA model</li> </ul> <p>All of these can be found in our <a href="https://github.com/qipeng/golden-retriever" rel="external nofollow noopener" target="_blank">code repository on GitHub</a>.</p> <p><strong>Language Note:</strong> All datasets and most of the research mentioned in this post are collected/tested for the English language only, but our principle of semantic overlap is applicable to answering open-domain complex questions in other languages than English if suitably augmented with lemmatization for highly inflected languages.</p> <h4 id="acknowledgements">Acknowledgements</h4> <p>I would like to thank my collaborators Xiaowen (Vera) Lin, Leo Mehr, Zijian Wang, and Chris Manning for their help to make this work possible. I would also like to thank Nelson Liu and Andrey Kurenkov, who provided helpful editing suggestions for earlier drafts of this blog post.</p> <h4 id="footnotes">Footnotes</h4> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:2"> <p>This is of course contingent on the fact that very few highly ranked articles on the Web mention Jason Momoa in his next movie in close proximity to stating that he’s the “Aquaman” star who played Aquaman in that movie. This is just an example to demonstrate that as simple as this question seems, it’s not too difficult to construct questions that require information from more than one document to answer. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:4"> <p>By “gold documents” we mean the documents needed in the chain of reasoning to answer the question. <a href="#fnref:4" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:3"> <p>Comparison questions make up about 25% of the HotpotQA dataset. For more details please see <a href="https://arxiv.org/pdf/1809.09600.pdf" rel="external nofollow noopener" target="_blank">our HotpotQA paper</a>. <a href="#fnref:3" class="reversefootnote" role="doc-backlink">↩</a></p> </li> </ol> </div> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/stop-using-hotpotqa/">Why You Should Stop Using HotpotQA for AI Agents Evaluation in 2025</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/ai-is-the-new-rocket-science/">AI is the New Rocket Science</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/what-do-industry-researchers-do-part-2/">What do industry researchers do, anyway? Part 2 -- What do they do when they are not publishing</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/what-do-industry-researchers-do-part-1/">What do industry researchers do, anyway? Part 1 -- How to choose a team</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/what-do-industry-researchers-do-part-0/">What do industry researchers do, anyway? Part 0 -- Academia vs Industry</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Peng Qi. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?70d799092f862ad98c7876aa47712e20"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-GCCS3HYQ9Z"></script> <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
      dataLayer.push(arguments);
    }
    gtag('js', new Date());
    gtag('config', 'G-GCCS3HYQ9Z');
  </script> <script defer src="/assets/js/google-analytics-setup.js?12374742c4b1801ba82226e617af7e2d"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>